diff --git a/Makefile b/Makefile
index 328f9c6..968efd3 100644
--- a/Makefile
+++ b/Makefile
@@ -50,6 +50,11 @@ endif
 
 QEMU = qemu-system-riscv64
 
+
+ifndef SCHEDFLAG
+SCHEDFLAG := DEFAULT
+endif
+
 CC = $(TOOLPREFIX)gcc
 AS = $(TOOLPREFIX)gas
 LD = $(TOOLPREFIX)ld
@@ -62,6 +67,7 @@ CFLAGS += -mcmodel=medany
 CFLAGS += -ffreestanding -fno-common -nostdlib -mno-relax
 CFLAGS += -I.
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+CFLAGS += -D $(SCHEDFLAG)
 
 # Disable PIE when possible (for Ubuntu 16.10 toolchain)
 ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
@@ -132,9 +138,12 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_tomer\
+	
+	
 
-fs.img: mkfs/mkfs README $(UPROGS)
-	mkfs/mkfs fs.img README $(UPROGS)
+fs.img: mkfs/mkfs README path $(UPROGS)
+	mkfs/mkfs fs.img README path $(UPROGS)
 
 -include kernel/*.d user/*.d
 
@@ -153,9 +162,10 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 3
+CPUS := 1
 endif
 
+
 QEMUOPTS = -machine virt -bios none -kernel $K/kernel -m 128M -smp $(CPUS) -nographic
 QEMUOPTS += -drive file=fs.img,if=none,format=raw,id=x0
 QEMUOPTS += -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0
diff --git a/kernel/betkvarot.c b/kernel/betkvarot.c
new file mode 100644
index 0000000..5b56b16
--- /dev/null
+++ b/kernel/betkvarot.c
@@ -0,0 +1,22 @@
+ if(shouldPrint==0)
+      {
+        //printf("FCFS scheduler");
+        shouldPrint=1;
+      }
+
+      for(p = proc; p < &proc[NPROC]; p++) {
+        acquire(&p->lock);
+        while(p->state == RUNNABLE) {
+          // Switch to chosen process.  It is the process's job
+          // to release its lock and then reacquire it
+          // before jumping back to us.
+          p->state = RUNNING;
+          c->proc = p;
+          swtch(&c->context, &p->context);
+
+          // Process is done running for now.
+          // It should have changed its p->state before coming back.
+          c->proc = 0;
+        }
+        release(&p->lock);
+      }
\ No newline at end of file
diff --git a/kernel/defs.h b/kernel/defs.h
index 41098f4..c32d019 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -8,6 +8,8 @@ struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
+struct perf;
+
 
 // bio.c
 void            binit(void);
@@ -90,6 +92,7 @@ void            proc_mapstacks(pagetable_t);
 pagetable_t     proc_pagetable(struct proc *);
 void            proc_freepagetable(pagetable_t, uint64);
 int             kill(int);
+int             trace(int,int);
 struct cpu*     mycpu(void);
 struct cpu*     getmycpu(void);
 struct proc*    myproc();
@@ -100,11 +103,15 @@ void            setproc(struct proc*);
 void            sleep(void*, struct spinlock*);
 void            userinit(void);
 int             wait(uint64);
+int             wait_stat(uint64, struct perf* );
 void            wakeup(void*);
 void            yield(void);
+void            IncTimes(uint);
 int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
 int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
 void            procdump(void);
+void            printTrace(int, char*, int);
+int             set_priority(int);
 
 // swtch.S
 void            swtch(struct context*, struct context*);
@@ -140,6 +147,7 @@ int             fetchstr(uint64, char*, int);
 int             fetchaddr(uint64, uint64*);
 void            syscall();
 
+
 // trap.c
 extern uint     ticks;
 void            trapinit(void);
diff --git a/kernel/main.c b/kernel/main.c
index 5d7ad49..87d8b2e 100644
--- a/kernel/main.c
+++ b/kernel/main.c
@@ -4,8 +4,11 @@
 #include "riscv.h"
 #include "defs.h"
 
+
 volatile static int started = 0;
 
+
+
 // start() jumps here in supervisor mode on all CPUs.
 void
 main()
diff --git a/kernel/param.h b/kernel/param.h
index b5fdcb2..53a07aa 100644
--- a/kernel/param.h
+++ b/kernel/param.h
@@ -11,3 +11,5 @@
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
 #define FSSIZE       1000  // size of file system in blocks
 #define MAXPATH      128   // maximum file path name
+#define QUANTUM      5     // time quatum- number of ticks defined as one quantum
+#define ALPHA        50    // The param for approximation for SRT
diff --git a/kernel/proc.c b/kernel/proc.c
index 22e7ce4..0042831 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -5,16 +5,26 @@
 #include "spinlock.h"
 #include "proc.h"
 #include "defs.h"
+#include "syscall.h"
 
 struct cpu cpus[NCPU];
 
 struct proc proc[NPROC];
 
+int shouldPrint=0;
+
+
 struct proc *initproc;
 
 int nextpid = 1;
 struct spinlock pid_lock;
 
+
+
+int procCurrPrior=0;
+struct spinlock proc_priority_lock;
+
+
 extern void forkret(void);
 static void freeproc(struct proc *p);
 
@@ -26,6 +36,35 @@ extern char trampoline[]; // trampoline.S
 // must be acquired before any p->lock.
 struct spinlock wait_lock;
 
+void printStateName(struct proc *p)
+{
+  switch (p->state)
+  {
+  case RUNNING:
+    printf("Process number %d is in state: RUNNING, and BurstTime of: %d\n",p->pid, p->myPerf.average_bursttime);
+    break;
+  case RUNNABLE:
+    printf("Process number %d is in state: RUNNABLE, and BurstTime of: %d\n",p->pid, p->myPerf.average_bursttime);
+    break;
+  case SLEEPING:
+    printf("Process number %d is in state: SLEEPING, and BurstTime of: %d\n",p->pid, p->myPerf.average_bursttime);
+    break;
+  case UNUSED:
+    //printf("Process number %d is in state: UNUSED, and BurstTime of: %d\n",p->pid, p->myPerf.average_bursttime);
+    break;
+  case USED:
+    //printf("Process number %d is in state: USED, and BurstTime of: %d\n",p->pid, p->myPerf.average_bursttime);
+    break;
+  case ZOMBIE:
+    //printf("Process number %d is in state: ZOMBIE, and BurstTime of: %d\n",p->pid, p->myPerf.average_bursttime);
+    break;
+  
+  default:
+    break;
+  }
+  
+}
+
 // Allocate a page for each process's kernel stack.
 // Map it high in memory, followed by an invalid
 // guard page.
@@ -108,6 +147,7 @@ allocproc(void)
 
   for(p = proc; p < &proc[NPROC]; p++) {
     acquire(&p->lock);
+    
     if(p->state == UNUSED) {
       goto found;
     } else {
@@ -117,8 +157,26 @@ allocproc(void)
   return 0;
 
 found:
+  
   p->pid = allocpid();
+  
   p->state = USED;
+  
+  p->print_mask=0;
+
+  p->myPerf.ctime=ticks;
+  p->myPerf.ttime=ticks;
+
+  p-> myPerf.stime=0; 
+  p-> myPerf.retime=0;
+  p-> myPerf.rutime=0;
+  p->myPerf.average_bursttime=QUANTUM*100;
+  p->currentB=0;
+  p->decay_factor = 5;
+  p->lastTickRun= ticks;
+
+  
+  
 
   // Allocate a trapframe page.
   if((p->trapframe = (struct trapframe *)kalloc()) == 0){
@@ -140,7 +198,7 @@ found:
   memset(&p->context, 0, sizeof(p->context));
   p->context.ra = (uint64)forkret;
   p->context.sp = p->kstack + PGSIZE;
-
+  
   return p;
 }
 
@@ -164,6 +222,12 @@ freeproc(struct proc *p)
   p->killed = 0;
   p->xstate = 0;
   p->state = UNUSED;
+  p->myPerf.ctime=0;
+  p->myPerf.ttime=0;
+  p->myPerf.stime=0;
+  p->myPerf.retime=0;
+  p->myPerf.rutime=0;
+  p->myPerf.average_bursttime=0;
 }
 
 // Create a user page table for a given process,
@@ -273,18 +337,46 @@ int
 fork(void)
 {
   int i, pid;
+  int pmask;
+  int checkTrace;
+  
   struct proc *np;
   struct proc *p = myproc();
 
+  pmask=p->print_mask;
+  checkTrace=1;
+  checkTrace=checkTrace<<SYS_fork;
+  checkTrace=checkTrace&pmask;
+  
   // Allocate process.
   if((np = allocproc()) == 0){
+
+    if(p->print_mask!=0)
+    {
+      if(checkTrace)
+      {
+        printf("%d: syscall fork NULL-> %d\n",p->pid,-1);
+      }
+    }
     return -1;
   }
 
+  //Set process' priority to be as parents'
+  np->decay_factor=p->decay_factor;
+
   // Copy user memory from parent to child.
   if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
     freeproc(np);
     release(&np->lock);
+    ///
+    if(p->print_mask!=0)
+    {
+      if(checkTrace)
+      {
+         printf("%d: syscall fork NULL-> %d\n",p->pid,-1);
+      }
+    }
+    ///
     return -1;
   }
   np->sz = p->sz;
@@ -311,10 +403,24 @@ fork(void)
   np->parent = p;
   release(&wait_lock);
 
+  acquire(&proc_priority_lock);
+  np->fcfs_prior=procCurrPrior;
+  procCurrPrior=procCurrPrior+1;
+  release(&proc_priority_lock);
+
   acquire(&np->lock);
   np->state = RUNNABLE;
   release(&np->lock);
 
+  ///
+    if(p->print_mask!=0)
+    {
+      if(checkTrace)
+      {
+        printf("%d: syscall fork NULL-> %d\n",p->pid,pid);
+      }
+    }
+  ///
   return pid;
 }
 
@@ -369,6 +475,7 @@ exit(int status)
   acquire(&p->lock);
 
   p->xstate = status;
+  p->myPerf.ttime=ticks;
   p->state = ZOMBIE;
 
   release(&wait_lock);
@@ -399,6 +506,71 @@ wait(uint64 addr)
 
         havekids = 1;
         if(np->state == ZOMBIE){
+          
+
+///// Copy from kernel to user.
+// Copy len bytes from src to virtual address dstva in a given page table.
+// Return 0 on success, -1 on error.
+///int
+///copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
+
+          // Found one.
+          pid = np->pid;
+          if(addr != 0 && copyout(p->pagetable, addr, (char *)&np->xstate,
+                                  sizeof(np->xstate)) < 0) {
+            release(&np->lock);
+            release(&wait_lock);
+            return -1;
+          }
+          freeproc(np);
+          release(&np->lock);
+          release(&wait_lock);
+          return pid;
+        }
+        release(&np->lock);
+      }
+    }
+
+    // No point waiting if we don't have any children.
+    if(!havekids || p->killed){
+      release(&wait_lock);
+      return -1;
+    }
+    
+    // Wait for a child to exit.
+    sleep(p, &wait_lock);  //DOC: wait-sleep
+  }
+}
+
+
+// Wait for a child process to exit and return its pid.
+// Return -1 if this process has no children.
+int
+wait_stat(uint64 addr, struct perf* performance)
+{
+  struct proc *np;
+  int havekids, pid;
+  struct proc *p = myproc();
+  
+  acquire(&wait_lock);
+
+  for(;;){
+    // Scan through table looking for exited children.
+    havekids = 0;
+    for(np = proc; np < &proc[NPROC]; np++){
+      if(np->parent == p){
+        // make sure the child isn't still in exit() or swtch().
+        acquire(&np->lock);
+        havekids = 1;
+        if(np->state == ZOMBIE){
+
+          np->myPerf.ttime=ticks;
+
+          
+          if(copyout(p->pagetable,(uint64)performance->ctime,(char *)&np->myPerf,sizeof(np->myPerf))<0)
+          {
+            printf("Error copyout1\n");
+          }
           // Found one.
           pid = np->pid;
           if(addr != 0 && copyout(p->pagetable, addr, (char *)&np->xstate,
@@ -435,32 +607,258 @@ wait(uint64 addr)
 //  - eventually that process transfers control
 //    via swtch back to the scheduler.
 void
-scheduler(void)
+scheduler()
 {
   struct proc *p;
   struct cpu *c = mycpu();
+
   
   c->proc = 0;
   for(;;){
     // Avoid deadlock by ensuring that devices can interrupt.
     intr_on();
 
-    for(p = proc; p < &proc[NPROC]; p++) {
-      acquire(&p->lock);
-      if(p->state == RUNNABLE) {
+    
+    #ifdef DEFAULT
+      if(shouldPrint==0)
+      {
+        shouldPrint=1;
+      }
+
+      for(p = proc; p < &proc[NPROC]; p++) {
+        acquire(&p->lock);
+        if(p->state == RUNNABLE) {
+          // Switch to chosen process.  It is the process's job
+          // to release its lock and then reacquire it
+          // before jumping back to us.
+          p->state = RUNNING;
+          c->proc = p;
+          swtch(&c->context, &p->context);
+
+          // Process is done running for now.
+          // It should have changed its p->state before coming back.
+          c->proc = 0;
+        }
+        release(&p->lock);
+      }
+    
+    
+    #else
+
+    #ifdef FCFS
+   
+      int minProcPrior=0;
+      struct proc *minProcToRun=proc;
+      //Search for process with minimum burst time
+      for(p = proc; p < &proc[NPROC]; p++) {
+        
+        acquire(&p->lock);
+        if(p->state == RUNNABLE && minProcPrior==0)
+        {
+          minProcToRun=p;
+          minProcPrior=p->fcfs_prior;
+        }
+        else
+        {
+          if(p->state==RUNNABLE)
+          {
+            
+            if(p->fcfs_prior<minProcPrior)
+            {
+              minProcPrior=p->fcfs_prior;
+              minProcToRun=p;
+            }
+          }          
+        }
+        release(&p->lock);
+      }
+
+      acquire(&minProcToRun->lock);
+      if(minProcToRun->state == RUNNABLE) {
         // Switch to chosen process.  It is the process's job
         // to release its lock and then reacquire it
         // before jumping back to us.
-        p->state = RUNNING;
-        c->proc = p;
-        swtch(&c->context, &p->context);
+        minProcToRun->state = RUNNING;
+        
+        c->proc = minProcToRun;
+        swtch(&c->context, &minProcToRun->context);
 
         // Process is done running for now.
         // It should have changed its p->state before coming back.
         c->proc = 0;
       }
-      release(&p->lock);
-    }
+      release(&minProcToRun->lock);
+    
+
+    #else
+ 
+
+    #ifdef SRT
+    if(shouldPrint==0)
+      {
+        
+        shouldPrint=1;
+      }
+   
+      int minBurstTime=-999;
+      struct proc *minProcToRun=proc;
+      //Search for process with minimum burst time
+      for(p = proc; p < &proc[NPROC]; p++) {
+        
+        acquire(&p->lock);
+        if(p->state == RUNNABLE && minBurstTime==-999)
+        {
+          minProcToRun=p;
+          minBurstTime=p->myPerf.average_bursttime;
+        }
+        else
+        {
+          if(p->state==RUNNABLE)
+          {
+            
+            if(p->myPerf.average_bursttime<minBurstTime)
+            {
+              minBurstTime=p->myPerf.average_bursttime;
+              minProcToRun=p;
+            }
+          }          
+        }
+        release(&p->lock);
+      }
+
+      acquire(&minProcToRun->lock);
+      if(minProcToRun->state == RUNNABLE) {
+        // Switch to chosen process.  It is the process's job
+        // to release its lock and then reacquire it
+        // before jumping back to us.
+        minProcToRun->state = RUNNING;
+        
+        c->proc = minProcToRun;
+        swtch(&c->context, &minProcToRun->context);
+
+        // Process is done running for now.
+        // It should have changed its p->state before coming back.
+        c->proc = 0;
+      }
+      release(&minProcToRun->lock);
+      
+
+    
+    #else
+
+    #ifdef CFSD
+    
+    if(shouldPrint==0)
+      {
+       
+        shouldPrint=1;
+      }
+
+      int isFirstCFSD = -999;
+      struct proc *procToRun=proc;
+
+
+      ///A/B > C/D ---> A*D > C*B
+
+      int numerA_curr;
+      int numerC_min;
+      int denomB_curr;
+      int denomD_min;
+      //Search for process with minimum runtime ratio
+      for(p = proc; p < &proc[NPROC]; p++) {
+        acquire(&p->lock);
+        if(p->state == RUNNABLE && isFirstCFSD==-999)
+        {
+          
+          procToRun=p;
+         
+          numerC_min=(p->myPerf.rutime) * p->decay_factor;
+          denomD_min=p->myPerf.rutime + p->myPerf.stime;
+          
+          isFirstCFSD=1;
+        }
+        else
+        {
+          if(p->state == RUNNABLE)
+          {
+            
+            denomB_curr=p->myPerf.rutime + p->myPerf.stime;
+            numerA_curr=(p->myPerf.rutime) * p->decay_factor;
+            int currIsZero=0;
+            int minIsZero=0;
+            if(denomB_curr==0 || numerA_curr == 0)
+            {
+              currIsZero=1;
+            }
+            if(denomD_min==0 || numerC_min==0)
+            {
+              minIsZero=1;
+            }
+            //00
+            //01
+            //10
+            //11
+   
+
+            if(currIsZero==0 && minIsZero==1)
+            {
+              denomD_min=denomD_min;
+              numerC_min=numerC_min;
+              procToRun=procToRun;
+            }  
+
+            else if(currIsZero==1 && minIsZero==0)
+            {
+              denomD_min=denomB_curr;
+              numerC_min=numerA_curr;
+              procToRun=p;
+            }  
+            else if(currIsZero==1 && minIsZero==1)
+            {
+              denomD_min=denomD_min;
+              numerC_min=denomD_min;
+              procToRun=procToRun;
+            }          
+            else
+            {
+              
+              if(numerA_curr*denomD_min>=numerC_min*denomB_curr)
+              {
+                //Curr is bigger, don't take
+              }
+              else{
+                denomD_min=denomB_curr;
+                numerC_min=numerA_curr;
+                procToRun=p;
+              }
+            }
+          }        
+        }
+        release(&p->lock);
+      }
+
+      acquire(&procToRun->lock);
+      if(procToRun->state == RUNNABLE) {
+        // Switch to chosen process.  It is the process's job
+        // to release its lock and then reacquire it
+        // before jumping back to us.
+        procToRun->state = RUNNING;
+        
+        c->proc = procToRun;
+        swtch(&c->context, &procToRun->context);
+
+        // Process is done running for now.
+        // It should have changed its p->state before coming back.
+        c->proc = 0;
+      }
+      release(&procToRun->lock);
+
+    #endif
+    #endif
+    #endif
+    #endif
+
+    
   }
 }
 
@@ -486,7 +884,27 @@ sched(void)
   if(intr_get())
     panic("sched interruptible");
 
+  
   intena = mycpu()->intena;
+
+
+  
+  int Ai=p->myPerf.average_bursttime;
+  int Bi=  p->currentB;
+  int Aiplus1=p->myPerf.average_bursttime;
+
+
+  Aiplus1=ALPHA*Bi+((100-ALPHA)*Ai)/100; 
+  p->myPerf.average_bursttime=Aiplus1;
+  p->currentB=0;
+  
+  //FCFS
+  p->lastTickRun=ticks;
+  acquire(&proc_priority_lock);
+  p->fcfs_prior=procCurrPrior;
+  procCurrPrior=procCurrPrior+1;
+  release(&proc_priority_lock);
+
   swtch(&p->context, &mycpu()->context);
   mycpu()->intena = intena;
 }
@@ -502,6 +920,46 @@ yield(void)
   release(&p->lock);
 }
 
+// Increment all proceeses time count
+void
+IncTimes(uint ticks)
+{
+  acquire(&wait_lock);
+  struct proc *p;
+  for(p = proc; p < &proc[NPROC]; p++){
+    acquire(&p->lock);
+
+    switch (p->state)
+    {
+    case RUNNABLE:
+      //printf("Runnable: %d\n",p->myPerf.retime);
+      p->myPerf.retime++;
+      p->currentB=0;
+      break;
+    
+    case RUNNING:
+      //printf("Running: %d\n",p->myPerf.rutime);
+      
+      p->myPerf.rutime++;
+      p->currentB++;
+      break;
+    
+    case SLEEPING:
+      //printf("Sleeping: %d\n",p->myPerf.stime);
+      p->myPerf.stime++;
+      p->currentB=0;
+      break;
+    
+    default:
+      break;
+    }
+    //release(&proc->lock);
+    release(&p->lock);
+  }
+  release(&wait_lock);
+  
+}
+
 // A fork child's very first scheduling by scheduler()
 // will swtch to forkret.
 void
@@ -565,6 +1023,10 @@ wakeup(void *chan)
     if(p != myproc()){
       acquire(&p->lock);
       if(p->state == SLEEPING && p->chan == chan) {
+        acquire(&proc_priority_lock);
+        p->fcfs_prior=procCurrPrior;
+        procCurrPrior=procCurrPrior+1;
+        release(&proc_priority_lock);
         p->state = RUNNABLE;
       }
       release(&p->lock);
@@ -580,15 +1042,67 @@ kill(int pid)
 {
   struct proc *p;
 
+  int pmask;
+  struct proc *myP;
+  int checkTrace;
+  
+  myP = myproc();
+
+  pmask=myP->print_mask;
+  checkTrace=1;
+  checkTrace=checkTrace<<SYS_kill;
+  checkTrace=checkTrace&pmask;
+
+
   for(p = proc; p < &proc[NPROC]; p++){
     acquire(&p->lock);
     if(p->pid == pid){
+      
       p->killed = 1;
+      p->myPerf.ttime=ticks;
       if(p->state == SLEEPING){
         // Wake process from sleep().
         p->state = RUNNABLE;
       }
       release(&p->lock);
+      
+      if(myP->print_mask!=0)
+      {
+        
+        if(checkTrace)
+        {
+          printf("%d: syscall kill %d-> %d\n",myP->pid,pid,0);
+        }
+      }
+      return 0;
+    }
+    release(&p->lock);
+  }
+  if(myP->print_mask!=0)
+  {
+    if(checkTrace)
+    {
+      printf("%d: syscall kill %d-> %d\n",myP->pid,pid,-1);
+    }
+  }
+  return -1;
+}
+
+// Kill the process with the given pid.
+// The victim won't exit until it tries to return
+// to user space (see usertrap() in trap.c).
+int
+trace(int mask, int pid)
+{
+  struct proc *p;
+
+  for(p = proc; p < &proc[NPROC]; p++){
+    acquire(&p->lock);
+    if(p->pid == pid){
+      ///our change
+      p->print_mask=mask;
+      ///
+      release(&p->lock);
       return 0;
     }
     release(&p->lock);
@@ -596,6 +1110,7 @@ kill(int pid)
   return -1;
 }
 
+
 // Copy to either a user address, or kernel address,
 // depending on usr_dst.
 // Returns 0 on success, -1 on error.
@@ -654,3 +1169,35 @@ procdump(void)
     printf("\n");
   }
 }
+
+int
+set_priority(int priority){
+  struct proc *p = myproc();
+  switch (priority)
+  {
+  case 1:
+    p->decay_factor = 1;
+    return 0;
+    break;
+  case 2:
+    p->decay_factor = 3;
+    return 0;
+    break;
+  case 3:
+    p->decay_factor = 5;
+    return 0;
+    break;
+  case 4:
+    p->decay_factor = 7;
+    return 0;
+    break;
+  case 5:
+    p->decay_factor = 25;
+    return 0;
+    break;
+  default:
+    return -1;
+    break;
+  }
+}
+
diff --git a/kernel/proc.h b/kernel/proc.h
index 8e90008..00f7b63 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -18,6 +18,17 @@ struct context {
   uint64 s11;
 };
 
+
+struct perf
+{
+    int ctime;
+    int ttime;
+    int stime;
+    int retime;
+    int rutime;
+    int average_bursttime;
+};
+
 // Per-CPU state.
 struct cpu {
   struct proc *proc;          // The process running on this cpu, or null.
@@ -82,6 +93,8 @@ struct trapframe {
 
 enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
 
+
+
 // Per-process state
 struct proc {
   struct spinlock lock;
@@ -93,6 +106,8 @@ struct proc {
   int xstate;                  // Exit status to be returned to parent's wait
   int pid;                     // Process ID
 
+  int print_mask;              //Own mask to print sys calls
+
   // proc_tree_lock must be held when using this:
   struct proc *parent;         // Parent process
 
@@ -105,4 +120,15 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+
+
+  //Schedualing measurenemts
+
+  struct perf myPerf;
+  int currentB;
+  int decay_factor;
+  int lastTickRun;
+  int fcfs_prior;
+
+
 };
diff --git a/kernel/syscall.c b/kernel/syscall.c
index c1b3670..bf11205 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -104,29 +104,66 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_wait(void);
 extern uint64 sys_write(void);
 extern uint64 sys_uptime(void);
+extern uint64 sys_trace(void);
+extern uint64 sys_wait_stat(void);
+extern uint64 sys_set_priority(void);
+
+
+
+static char* sysnames[]=
+{
+[SYS_fork]          "fork",
+[SYS_exit]          "exit",
+[SYS_wait]          "wait",
+[SYS_pipe]          "pipe",
+[SYS_read]          "read",
+[SYS_kill]          "kill",
+[SYS_exec]          "exec",
+[SYS_fstat]         "fstat",
+[SYS_chdir]         "chdir",
+[SYS_dup]           "dup",
+[SYS_getpid]        "getpid",
+[SYS_sbrk]          "sbrk",
+[SYS_sleep]         "sleep",
+[SYS_uptime]        "uptime",
+[SYS_open]          "open",
+[SYS_write]         "write",
+[SYS_mknod]         "mknod",
+[SYS_unlink]        "unlink",
+[SYS_link]          "link",
+[SYS_mkdir]         "mkdir",
+[SYS_close]         "close",
+[SYS_trace]         "trace",
+[SYS_wait_stat]     "wait_stat",
+[SYS_set_priority]  "set_priority",
+
+};
 
 static uint64 (*syscalls[])(void) = {
-[SYS_fork]    sys_fork,
-[SYS_exit]    sys_exit,
-[SYS_wait]    sys_wait,
-[SYS_pipe]    sys_pipe,
-[SYS_read]    sys_read,
-[SYS_kill]    sys_kill,
-[SYS_exec]    sys_exec,
-[SYS_fstat]   sys_fstat,
-[SYS_chdir]   sys_chdir,
-[SYS_dup]     sys_dup,
-[SYS_getpid]  sys_getpid,
-[SYS_sbrk]    sys_sbrk,
-[SYS_sleep]   sys_sleep,
-[SYS_uptime]  sys_uptime,
-[SYS_open]    sys_open,
-[SYS_write]   sys_write,
-[SYS_mknod]   sys_mknod,
-[SYS_unlink]  sys_unlink,
-[SYS_link]    sys_link,
-[SYS_mkdir]   sys_mkdir,
-[SYS_close]   sys_close,
+[SYS_fork]        sys_fork,
+[SYS_exit]        sys_exit,
+[SYS_wait]        sys_wait,
+[SYS_pipe]        sys_pipe,
+[SYS_read]        sys_read,
+[SYS_kill]        sys_kill,
+[SYS_exec]        sys_exec,
+[SYS_fstat]       sys_fstat,
+[SYS_chdir]       sys_chdir,
+[SYS_dup]         sys_dup,
+[SYS_getpid]      sys_getpid,
+[SYS_sbrk]        sys_sbrk,
+[SYS_sleep]       sys_sleep,
+[SYS_uptime]      sys_uptime,
+[SYS_open]        sys_open,
+[SYS_write]       sys_write,
+[SYS_mknod]       sys_mknod,
+[SYS_unlink]      sys_unlink,
+[SYS_link]        sys_link,
+[SYS_mkdir]       sys_mkdir,
+[SYS_close]       sys_close,
+[SYS_trace]       sys_trace,
+[SYS_wait_stat]   sys_wait_stat,
+[SYS_set_priority] sys_set_priority,
 };
 
 void
@@ -134,13 +171,32 @@ syscall(void)
 {
   int num;
   struct proc *p = myproc();
+  int returnVal=-1;
 
   num = p->trapframe->a7;
   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
-    p->trapframe->a0 = syscalls[num]();
+    returnVal=syscalls[num]();
+    p->trapframe->a0 = returnVal;
   } else {
     printf("%d %s: unknown sys call %d\n",
             p->pid, p->name, num);
     p->trapframe->a0 = -1;
   }
+
+  if(p->print_mask) //General check that the mask is not zero
+  {
+    if(p->print_mask & (1<<num)) // if the requested syscall is traced
+    {
+      if(num==SYS_fork || num==SYS_kill || num==SYS_sbrk)
+      {
+        //print will be inside
+      }
+      else
+      {
+        printf("%d: syscall %s -> %d\n",p->pid,sysnames[num],returnVal);
+      }
+      
+    }
+  }
+
 }
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..0ac913d 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -1,22 +1,25 @@
-// System call numbers
-#define SYS_fork    1
-#define SYS_exit    2
-#define SYS_wait    3
-#define SYS_pipe    4
-#define SYS_read    5
-#define SYS_kill    6
-#define SYS_exec    7
-#define SYS_fstat   8
-#define SYS_chdir   9
-#define SYS_dup    10
-#define SYS_getpid 11
-#define SYS_sbrk   12
-#define SYS_sleep  13
-#define SYS_uptime 14
-#define SYS_open   15
-#define SYS_write  16
-#define SYS_mknod  17
-#define SYS_unlink 18
-#define SYS_link   19
-#define SYS_mkdir  20
-#define SYS_close  21
+// System call numbers    
+#define SYS_fork            1
+#define SYS_exit            2
+#define SYS_wait            3
+#define SYS_pipe            4
+#define SYS_read            5
+#define SYS_kill            6
+#define SYS_exec            7
+#define SYS_fstat           8
+#define SYS_chdir           9
+#define SYS_dup             10
+#define SYS_getpid          11
+#define SYS_sbrk            12
+#define SYS_sleep           13
+#define SYS_uptime          14
+#define SYS_open            15
+#define SYS_write           16
+#define SYS_mknod           17
+#define SYS_unlink          18
+#define SYS_link            19
+#define SYS_mkdir           20
+#define SYS_close           21
+#define SYS_trace           22
+#define SYS_wait_stat       23
+#define SYS_set_priority    24
diff --git a/kernel/sysfile.c b/kernel/sysfile.c
index 5dc453b..4f2fdd4 100644
--- a/kernel/sysfile.c
+++ b/kernel/sysfile.c
@@ -15,6 +15,9 @@
 #include "sleeplock.h"
 #include "file.h"
 #include "fcntl.h"
+#include "syscall.h"
+
+
 
 // Fetch the nth word-sized system call argument as a file descriptor
 // and return both the descriptor and the corresponding struct file.
@@ -59,9 +62,13 @@ sys_dup(void)
   int fd;
 
   if(argfd(0, 0, &f) < 0)
+  {
     return -1;
+  }
   if((fd=fdalloc(f)) < 0)
+  {
     return -1;
+  }
   filedup(f);
   return fd;
 }
@@ -74,8 +81,11 @@ sys_read(void)
   uint64 p;
 
   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argaddr(1, &p) < 0)
+  {
     return -1;
-  return fileread(f, p, n);
+  }
+  int ans=fileread(f, p, n);
+  return ans;
 }
 
 uint64
@@ -85,10 +95,11 @@ sys_write(void)
   int n;
   uint64 p;
 
-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argaddr(1, &p) < 0)
+  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argaddr(1, &p) < 0){
     return -1;
-
-  return filewrite(f, p, n);
+  }
+  int ans = filewrite(f, p, n);
+  return ans;
 }
 
 uint64
@@ -97,8 +108,9 @@ sys_close(void)
   int fd;
   struct file *f;
 
-  if(argfd(0, &fd, &f) < 0)
+  if(argfd(0, &fd, &f) < 0){
     return -1;
+  }
   myproc()->ofile[fd] = 0;
   fileclose(f);
   return 0;
@@ -111,8 +123,11 @@ sys_fstat(void)
   uint64 st; // user pointer to struct stat
 
   if(argfd(0, 0, &f) < 0 || argaddr(1, &st) < 0)
+  {
     return -1;
-  return filestat(f, st);
+  }
+  int ans=filestat(f, st);
+  return ans;
 }
 
 // Create the path new as a link to the same inode as old.
@@ -122,8 +137,9 @@ sys_link(void)
   char name[DIRSIZ], new[MAXPATH], old[MAXPATH];
   struct inode *dp, *ip;
 
-  if(argstr(0, old, MAXPATH) < 0 || argstr(1, new, MAXPATH) < 0)
+  if(argstr(0, old, MAXPATH) < 0 || argstr(1, new, MAXPATH) < 0){
     return -1;
+  }
 
   begin_op();
   if((ip = namei(old)) == 0){
@@ -153,7 +169,6 @@ sys_link(void)
   iput(ip);
 
   end_op();
-
   return 0;
 
 bad:
@@ -189,8 +204,9 @@ sys_unlink(void)
   char name[DIRSIZ], path[MAXPATH];
   uint off;
 
-  if(argstr(0, path, MAXPATH) < 0)
+  if(argstr(0, path, MAXPATH) < 0){
     return -1;
+  }
 
   begin_op();
   if((dp = nameiparent(path, name)) == 0){
@@ -229,7 +245,6 @@ sys_unlink(void)
   iunlockput(ip);
 
   end_op();
-
   return 0;
 
 bad:
@@ -292,8 +307,9 @@ sys_open(void)
   struct inode *ip;
   int n;
 
-  if((n = argstr(0, path, MAXPATH)) < 0 || argint(1, &omode) < 0)
+  if((n = argstr(0, path, MAXPATH)) < 0 || argint(1, &omode) < 0){
     return -1;
+  }
 
   begin_op();
 
@@ -347,7 +363,6 @@ sys_open(void)
 
   iunlock(ip);
   end_op();
-
   return fd;
 }
 
@@ -445,7 +460,6 @@ sys_exec(void)
 
   for(i = 0; i < NELEM(argv) && argv[i] != 0; i++)
     kfree(argv[i]);
-
   return ret;
 
  bad:
@@ -463,9 +477,13 @@ sys_pipe(void)
   struct proc *p = myproc();
 
   if(argaddr(0, &fdarray) < 0)
+  {
     return -1;
+  }
   if(pipealloc(&rf, &wf) < 0)
+  {
     return -1;
+  }
   fd0 = -1;
   if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
     if(fd0 >= 0)
@@ -484,3 +502,4 @@ sys_pipe(void)
   }
   return 0;
 }
+
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index e8bcda9..360a9ff 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -6,13 +6,41 @@
 #include "memlayout.h"
 #include "spinlock.h"
 #include "proc.h"
+#include "syscall.h"
+
+
+
+
+void printTrace(int shiftNum, char* sysName, int retVal)
+{
+  int pmask;
+  int checkTrace;
+  
+  struct proc *p = myproc();
+
+  pmask=p->print_mask;
+  checkTrace=1;
+  checkTrace=checkTrace<<shiftNum;
+  checkTrace=checkTrace&pmask;
+  
+    if(p->print_mask!=0)
+    {
+      if(checkTrace)
+      {
+        printf("%d: syscall %s -> %d\n",p->pid,sysName,retVal);
+      }
+    }
+}
+
 
 uint64
 sys_exit(void)
 {
   int n;
   if(argint(0, &n) < 0)
+  {
     return -1;
+  }
   exit(n);
   return 0;  // not reached
 }
@@ -20,7 +48,8 @@ sys_exit(void)
 uint64
 sys_getpid(void)
 {
-  return myproc()->pid;
+  int ans=myproc()->pid;
+  return ans;
 }
 
 uint64
@@ -34,8 +63,11 @@ sys_wait(void)
 {
   uint64 p;
   if(argaddr(0, &p) < 0)
+  {
     return -1;
-  return wait(p);
+  }
+  int ans=wait(p);
+  return ans;
 }
 
 uint64
@@ -44,11 +76,41 @@ sys_sbrk(void)
   int addr;
   int n;
 
-  if(argint(0, &n) < 0)
+  struct proc *p;
+  int pmask;
+
+  p = myproc();
+  pmask=p->print_mask;
+
+  if(argint(0, &n) < 0){
+    if(pmask!=0)
+    {
+      if((1 << SYS_sbrk) & pmask)
+      {
+        printf("%d: syscall sbrk %d -> %d\n",p->pid, n, -1);
+      }
+    }
     return -1;
+  }
   addr = myproc()->sz;
-  if(growproc(n) < 0)
+  if(growproc(n) < 0){
+    if(pmask!=0)
+    {
+      if((1 << SYS_sbrk) & pmask)
+      {
+        printf("%d: syscall sbrk %d -> %d\n",p->pid, n, -1);
+      }
+    }
     return -1;
+  }
+
+  if(pmask!=0)
+  {
+    if((1 << SYS_sbrk) & pmask)
+    {
+      printf("%d: syscall sbrk %d -> %d\n",p->pid, n, addr);
+    }
+  }
   return addr;
 }
 
@@ -59,7 +121,9 @@ sys_sleep(void)
   uint ticks0;
 
   if(argint(0, &n) < 0)
+  {
     return -1;
+  }
   acquire(&tickslock);
   ticks0 = ticks;
   while(ticks - ticks0 < n){
@@ -95,3 +159,48 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+uint64
+sys_trace(void)
+{
+  int mask;
+  int pid;
+  if(argint(0, &mask) < 0){
+    return -1;
+  }
+  if(argint(1,&pid)<0)
+  {
+    return -1;
+  }
+  int ans = trace(mask,pid);
+  return ans;
+}
+
+uint64
+sys_set_priority(void)
+{
+  int priority;
+
+  if(argint(0, &priority) < 0)
+    return -1;
+  return set_priority(priority);
+}
+
+uint64
+sys_wait_stat(void)
+{
+  uint64 p;
+  uint64 performance;
+  
+  if(argaddr(0, &p) < 0)
+  {
+    return -1;
+  }
+  if(argaddr(1, &performance) < 0)
+  {
+    return -1;
+  }
+
+  int ans=wait_stat((uint64)p,(struct perf*)&performance);
+  return ans;
+}
\ No newline at end of file
diff --git a/kernel/trap.c b/kernel/trap.c
index a63249e..1fcb14c 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -8,6 +8,8 @@
 
 struct spinlock tickslock;
 uint ticks;
+int countToNextTick=0;
+
 
 extern char trampoline[], uservec[], userret[];
 
@@ -70,15 +72,59 @@ usertrap(void)
   } else {
     printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
     printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
+    p->myPerf.ttime=ticks; //british
     p->killed = 1;
   }
 
   if(p->killed)
     exit(-1);
 
+  
   // give up the CPU if this is a timer interrupt.
   if(which_dev == 2)
-    yield();
+  {
+    #ifdef DEFAULT
+    if(countToNextTick==QUANTUM)
+    {
+      countToNextTick=0;
+      yield();
+    }
+    else
+    {
+      countToNextTick++;
+    }
+    #else
+    #ifdef SRT
+    if(countToNextTick==QUANTUM)
+    {
+      countToNextTick=0;
+      yield();
+    }
+    else
+    {
+      countToNextTick++;
+    }
+    #else
+
+     #ifdef CFSD
+    if(countToNextTick==QUANTUM)
+    {
+      countToNextTick=0;
+      yield();
+    }
+    else
+    {
+      countToNextTick++;
+    }
+    #else
+    #ifdef FCFS
+    //Nothing
+    #endif
+    #endif
+    #endif
+    #endif
+    
+  }
 
   usertrapret();
 }
@@ -151,7 +197,50 @@ kerneltrap()
 
   // give up the CPU if this is a timer interrupt.
   if(which_dev == 2 && myproc() != 0 && myproc()->state == RUNNING)
-    yield();
+  {
+
+    #ifdef DEFAULT
+    if(countToNextTick==QUANTUM)
+    {
+      countToNextTick=0;
+      yield();
+    }
+    else
+    {
+      countToNextTick++;
+    }
+    #else
+    #ifdef SRT
+    if(countToNextTick==QUANTUM)
+    {
+      countToNextTick=0;
+      yield();
+    }
+    else
+    {
+      countToNextTick++;
+    }
+    #else
+
+     #ifdef CFSD
+    if(countToNextTick==QUANTUM)
+    {
+      countToNextTick=0;
+      yield();
+    }
+    else
+    {
+      countToNextTick++;
+    }
+    #else
+    #ifdef FCFS
+    //Nothing
+    #endif
+    #endif
+    #endif
+    #endif
+
+  }
 
   // the yield() may have caused some traps to occur,
   // so restore trap registers for use by kernelvec.S's sepc instruction.
@@ -162,8 +251,10 @@ kerneltrap()
 void
 clockintr()
 {
+  
   acquire(&tickslock);
   ticks++;
+  IncTimes(ticks);
   wakeup(&ticks);
   release(&tickslock);
 }
diff --git a/mkfs/mkfs.c b/mkfs/mkfs.c
index 246a4e2..2fa4c96 100644
--- a/mkfs/mkfs.c
+++ b/mkfs/mkfs.c
@@ -90,6 +90,8 @@ main(int argc, char *argv[])
     exit(1);
   }
 
+  
+
   // 1 fs block = 1 disk sector
   nmeta = 2 + nlog + ninodeblocks + nbitmap;
   nblocks = FSSIZE - nmeta;
diff --git a/path b/path
new file mode 100644
index 0000000..027c827
--- /dev/null
+++ b/path
@@ -0,0 +1 @@
+/:/user/:
\ No newline at end of file
diff --git a/user/KingTomer/printTomer.c b/user/KingTomer/printTomer.c
new file mode 100644
index 0000000..cddbe62
--- /dev/null
+++ b/user/KingTomer/printTomer.c
@@ -0,0 +1,23 @@
+#include "kernel/types.h"
+#include "user/user.h"
+#include "kernel/fcntl.h"
+#include "kernel/syscall.h"
+
+int main(int argc, char** argv)
+{
+    trace(1<<SYS_fork,getpid());
+    int newPid= fork();
+    if(newPid!=0)
+    {
+        int status;
+        wait(&status);
+        fprintf(2,"Child %d finished\n",newPid);
+    }
+    else
+    {
+        fprintf(2,"Child running\n");
+    }
+    
+    fprintf(2,"Hello tomer\n");
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/PATH b/user/PATH
new file mode 100644
index 0000000..027c827
--- /dev/null
+++ b/user/PATH
@@ -0,0 +1 @@
+/:/user/:
\ No newline at end of file
diff --git a/user/Untitled-1.c b/user/Untitled-1.c
new file mode 100644
index 0000000..2f71ec6
--- /dev/null
+++ b/user/Untitled-1.c
@@ -0,0 +1,70 @@
+
+    //Run the requested working directory
+    //if(ecmd->argv[0] == 0)
+      //exit(1);    
+    //exec(ecmd->argv[0], ecmd->argv);
+
+    ///If didn't work, run the directories specified by PATH file
+    
+    
+    read(path_fd, &buffer, buf_size);
+    char* ptr = buffer;
+    char* dots_ptr;
+    while((dots_ptr = strchr(ptr, ':'))){
+        *dots_ptr = '\0';
+        exec(ptr, ecmd->argv);
+        ptr = dots_ptr + 1;
+    }
+    fprintf(2, "exec %s failed\n", ecmd->argv[0]);
+    break;
+
+
+    //backup
+    ecmd = (struct execcmd*)cmd;
+    if(ecmd->argv[0] == 0)
+      exit(1);    
+    exec(ecmd->argv[0], ecmd->argv);
+    int path_fd;
+    char buffer[buf_size];
+    char* str;
+    path_fd= open("/path",O_RDWR);
+    if(path_fd<0)
+    {
+      path_fd=open("/path",O_CREATE|O_RDWR);
+      str= "/:/user/:";
+      write(path_fd,str,strlen(str));
+    }
+    
+    char* ptr = buffer;
+    read(path_fd, ptr, buf_size);
+    char* dots_ptr;
+    while((dots_ptr = strchr(ptr, ':'))){
+        *dots_ptr = '\0';
+        int length = strlen(ptr);
+        char cpy[length];
+        strcpy(cpy, ptr);
+        ecmd->argv[0] = cpy;
+        exec(ecmd->argv[0], ecmd->argv);
+        ptr = dots_ptr + 1;
+    }
+    fprintf(2, "exec %s failed\n", ecmd->argv[0]);
+
+
+
+    //fucking working
+    int path_fd=3;
+    char buffer[2000];
+    char* str;="hellpo";
+    buffer[0]='1';
+    if(ecmd->argv[0] == 0)
+      exit(1);    
+    exec(ecmd->argv[0], ecmd->argv);
+    
+    //buffer[0]='c';
+    
+    //path_fd= open("/path",O_RDWR);
+    fprintf(2,"%d",path_fd);
+    fprintf(2,"%c",buffer[0]);
+    fprintf(2,"%s",str);
+    //*buffer="hello";
+    break;
\ No newline at end of file
diff --git a/user/sh.c b/user/sh.c
index 83dd513..e7856df 100644
--- a/user/sh.c
+++ b/user/sh.c
@@ -4,6 +4,7 @@
 #include "user/user.h"
 #include "kernel/fcntl.h"
 
+
 // Parsed command representation
 #define EXEC  1
 #define REDIR 2
@@ -13,6 +14,8 @@
 
 #define MAXARGS 10
 
+const int BUF_SIZE = 1225;
+
 struct cmd {
   int type;
 };
@@ -53,6 +56,8 @@ int fork1(void);  // Fork but panics on failure.
 void panic(char*);
 struct cmd *parsecmd(char*);
 
+
+
 // Execute cmd.  Never returns.
 void
 runcmd(struct cmd *cmd)
@@ -63,6 +68,9 @@ runcmd(struct cmd *cmd)
   struct listcmd *lcmd;
   struct pipecmd *pcmd;
   struct redircmd *rcmd;
+  
+  
+
 
   if(cmd == 0)
     exit(1);
@@ -72,13 +80,49 @@ runcmd(struct cmd *cmd)
     panic("runcmd");
 
   case EXEC:
-    ecmd = (struct execcmd*)cmd;
+    ecmd=(struct execcmd*)cmd;
+
+    
+    int path_fd;
+    char buffer[2000];
+    char nextCmdToRun[500];
+    char* buffer_ptr = buffer;
+    
+    char* nextCmd_ptr=nextCmdToRun;
+    char* str;
     if(ecmd->argv[0] == 0)
-      exit(1);
+      exit(1);    
     exec(ecmd->argv[0], ecmd->argv);
+  
+    path_fd= open("/path",O_RDWR);
+    if(path_fd<0)
+    {
+      path_fd=open("/path",O_CREATE|O_RDWR);
+      fprintf(2,"creating new path file\n");
+      str= "/:/user/:";
+      write(path_fd,str,strlen(str));
+    }
+
+    
+    
+    read(path_fd, buffer_ptr, 2000);
+    char* dots_ptr; // points to nekudotaim
+    while((dots_ptr = strchr(buffer_ptr, ':'))){
+        
+        *dots_ptr = '\0';
+        int length = strlen(buffer_ptr);
+        strcpy(nextCmdToRun, buffer_ptr);
+        nextCmdToRun[length]='/';
+        strcpy(nextCmdToRun+length+1,ecmd->argv[0]);
+        ecmd->argv[0]=nextCmd_ptr;
+        exec(ecmd->argv[0], ecmd->argv);
+        buffer_ptr = dots_ptr + 1;
+        
+    }
+    
     fprintf(2, "exec %s failed\n", ecmd->argv[0]);
     break;
-
+  
   case REDIR:
     rcmd = (struct redircmd*)cmd;
     close(rcmd->fd);
@@ -144,6 +188,7 @@ getcmd(char *buf, int nbuf)
 int
 main(void)
 {
+
   static char buf[100];
   int fd;
 
diff --git a/user/toemr.txt b/user/toemr.txt
new file mode 100644
index 0000000..ce01362
--- /dev/null
+++ b/user/toemr.txt
@@ -0,0 +1 @@
+hello
diff --git a/user/tomer.c b/user/tomer.c
new file mode 100644
index 0000000..8d0aa07
--- /dev/null
+++ b/user/tomer.c
@@ -0,0 +1,231 @@
+#include "kernel/types.h"
+#include "user/user.h"
+#include "kernel/fcntl.h"
+#include "kernel/syscall.h"
+
+
+void someCode()
+{
+int i=0;
+   int count=0;
+   int newPid=fork();
+   if(newPid==0)
+   {
+       //Child
+       //sleep(5);
+       sleep(5);
+       for(i=0;i<__INT32_MAX__;i++)
+       {
+           count++;
+       }
+       sleep(1);
+       fprintf(2,"I am the child\n");
+       exit(0);
+   }
+   else
+   {
+        //Father
+        //int waitAns=wait(&newPid);
+        //fprintf(2,"Wait ans is: %d\n",waitAns);
+        
+        struct perf myperf;
+        //struct perf* myPerfPtr=&myperf;
+        struct perf* myperptr=&myperf;
+        myperptr->ctime=333;
+        fprintf(2,"User pref address: %d\n",&myperf);
+        int ans=wait_stat(&newPid,&myperf);
+        
+        
+        fprintf(2,"Ctime:%d\n",myperptr->ctime);
+        fprintf(2,"Ttime:%d\n",myperptr->ttime);
+        fprintf(2,"Stime:%d\n",myperptr->stime);
+        fprintf(2,"Retime:%d\n",myperptr->retime);
+        fprintf(2,"Rutime:%d\n",myperptr->rutime);
+        fprintf(2,"Ans:%d\n",ans);
+        exit(0);
+   }
+   
+
+    fprintf(2,"Hello tomer\n");
+
+    int status=5;
+    int waitAns=wait(&status);
+    fprintf(2,"Wait ans: %d",waitAns);
+
+    struct perf myperf;
+    struct perf* myPerfPtr=&myperf;
+    
+    int ans=wait_stat(&status,&myperf);
+    fprintf(2,"Ctime:%d\n",myPerfPtr->ctime);
+    fprintf(2,"Ttime:%d\n",myPerfPtr->ttime);
+    fprintf(2,"Stime:%d\n",myPerfPtr->stime);
+    fprintf(2,"Retime:%d\n",myPerfPtr->retime);
+    fprintf(2,"Rutime:%d\n",myPerfPtr->rutime);
+    fprintf(2,"Bursttime:%d\n",myPerfPtr->average_bursttime);
+    fprintf(2,"Ans:%d\n",ans);
+    wait(&status);
+    ans=wait_stat(&status,&myperf);
+    fprintf(2,"Ctime:%d\n",myPerfPtr->ctime);
+    fprintf(2,"Ttime:%d\n",myPerfPtr->ttime);
+    fprintf(2,"Stime:%d\n",myPerfPtr->stime);
+    fprintf(2,"Retime:%d\n",myPerfPtr->retime);
+    fprintf(2,"Rutime:%d\n",myPerfPtr->rutime);
+    fprintf(2,"Bursttime:%d\n",myPerfPtr->average_bursttime);
+    fprintf(2,"Ans:%d\n",ans);
+    
+    exit(0);
+}
+
+
+void testForFCFS()
+{
+    fprintf(2,"Welcome to tomer's show\n");
+    int i=0;
+    int kidA=fork();
+    int kidB;
+    if(kidA==0)
+    {
+        for (i = 0; i < __INT16_MAX__; i++)
+        {
+            fprintf(2,"A");
+        }
+        
+    }
+    else
+    {
+        //Father
+        sleep(1);
+        kidB=fork();
+        if(kidB==0)
+        {
+            //kidB
+            for (i = 0; i < __INT16_MAX__; i++)
+            {
+                fprintf(2,"B");
+            }
+        }
+        else
+        {
+            wait(&kidB);
+        }
+        wait(&kidA);
+        fprintf(2,"\nFather finished\n");
+        
+
+    }
+}
+
+void test3()
+{
+    struct perf perfF;
+    struct perf perfS;
+    int slowChild;
+    int fastChild;
+    slowChild=fork();
+    if(slowChild==0)
+    {
+        //In the slow child
+        for (int i = 0; i < __INT32_MAX__; i++)
+            {
+                fprintf(2,"S");
+            }
+    }
+    else
+    {
+        //Father
+        fastChild=fork();
+        if(fastChild==0)
+        {
+            //In fast child
+            for (int i = 0; i < __INT16_MAX__; i++)
+            {
+                fprintf(2,"F");
+            }
+        }
+        else
+        {
+            //Father
+            wait_stat(&fastChild, &perfF);
+        }
+        wait_stat(&slowChild, &perfS);
+    }
+
+    fprintf(2,"Hello tomer!");
+    exit(0);
+}
+
+void generalSchedCheck()
+{
+     struct perf perfMeyuhas;
+    struct perf perfBur;
+    int BurVeAmHaaretz;
+    int Meyuhas;
+    Meyuhas=fork();
+    if(Meyuhas==0)
+    {
+        sleep(1);
+        //In the slow child
+        //set_priority(2);
+        for (int i = 0; i < __INT16_MAX__; i++)
+        {
+            fprintf(2,"$");
+        }
+        exit(0);
+    }
+    else
+    {
+        //Father
+        BurVeAmHaaretz=fork();
+        if(BurVeAmHaaretz==0)
+        {
+            //In bur child
+            //set_priority(2);
+            for (int i = 0; i < __INT16_MAX__; i++)
+            {
+                fprintf(2,"!");
+                
+            }
+            exit(0);
+        }
+        else
+        {
+            //Father
+            wait_stat(&BurVeAmHaaretz, &perfBur);
+        }
+        wait_stat(&Meyuhas, &perfMeyuhas);
+    }
+
+    fprintf(2,"Hello tomer!");
+    exit(0);
+}
+
+
+void testTrace()
+{
+    //
+    int mask=  (1<<SYS_fork) | (1<<SYS_kill) | (1<<SYS_sbrk) |(1<<SYS_exit)|(1<<SYS_wait) |(1<<SYS_getpid);
+    trace(mask,getpid());
+    int pr=fork();
+    if(pr==0)
+    {
+        trace(mask,getpid());
+        fprintf(2,"I am the child\n");
+        sbrk(4096);
+        kill(getpid());
+        exit(0);
+    }
+    else
+    {
+        wait(&pr);
+    }
+    sleep(1);
+    exit(0);
+}
+
+int main(int argc, char** argv)
+{
+    someCode();
+    //testTrace();
+   //generalSchedCheck();
+   exit(0);
+}
\ No newline at end of file
diff --git a/user/user.h b/user/user.h
index b71ecda..b24bfc1 100644
--- a/user/user.h
+++ b/user/user.h
@@ -1,6 +1,17 @@
 struct stat;
 struct rtcdate;
 
+struct perf
+{
+    int ctime;
+    int ttime;
+    int stime;
+    int retime;
+    int rutime;
+    int average_bursttime;
+};
+
+
 // system calls
 int fork(void);
 int exit(int) __attribute__((noreturn));
@@ -23,6 +34,9 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int trace(int mask, int pid);
+int wait_stat(int* status,struct perf*);
+int set_priority(int priority);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..e3d790e 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,6 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("trace");
+entry("wait_stat");
+entry("set_priority");
